<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TF.js åˆ†å‰²æ¨¡å‹ mIoU æµ‹è¯•</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
        background-color: #f4f4f9;
      }
      h1,
      h2 {
        color: #333;
      }
      #status {
        padding: 10px;
        background-color: #e3f2fd;
        border-left: 5px solid #2196f3;
        margin-bottom: 20px;
      }
      #results {
        padding: 10px;
        background-color: #e8f5e9;
        border-left: 5px solid #4caf50;
        display: none;
      }
      #results p {
        margin: 5px 0;
      }
      .progress-bar {
        width: 100%;
        background-color: #ddd;
        border-radius: 5px;
      }
      .progress-bar-inner {
        width: 0%;
        height: 20px;
        background-color: #4caf50;
        text-align: center;
        line-height: 20px;
        color: white;
        border-radius: 5px;
        transition: width 0.3s;
      }
      code {
        background-color: #eee;
        padding: 2px 4px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>TensorFlow.js åˆ†å‰²æ¨¡å‹ mIoU æµ‹è¯•</h1>
    <p>æœ¬é¡µé¢å°†åŠ è½½æ‚¨çš„ TF.js åˆ†å‰²æ¨¡å‹ï¼Œå¹¶åœ¨æŒ‡å®šçš„æ•°æ®é›†ä¸Šè¯„ä¼°å…¶ mIoU æ€§èƒ½ã€‚</p>
    <p>
      æ¨¡å‹è¾“å…¥å°ºå¯¸: <code>[1, 3, 256, 144]</code>, è¾“å‡ºå°ºå¯¸:
      <code>[1, 2, 256, 144]</code>
    </p>
    <p>
      å½“å‰ TensorFlow.js åç«¯:
      <code id="backend-name">detectingâ€¦</code>
    </p>
    <!-- ===== æ§åˆ¶é¢æ¿ï¼šæ•°æ®é›†é€‰æ‹© & é˜ˆå€¼è®¾å®š ===== -->
    <div id="controls" style="margin-bottom: 20px">
      <label>
        é€‰æ‹©æ•°æ®é›†ç›®å½•ï¼š
        <!-- å…è®¸æ•´ç›®å½•é€‰æ‹©ï¼›Chrome åŠå¤šæ•° Chromium å†…æ ¸æµè§ˆå™¨æ”¯æŒ -->
        <input
          type="file"
          id="dataset-input"
          webkitdirectory
          directory
          multiple
        />
      </label>
      <label style="margin-left: 16px">
        é˜ˆå€¼ï¼š
        <input
          type="number"
          id="threshold-input"
          value="0.6"
          step="0.05"
          min="0"
          max="1"
          style="width: 70px"
        />
      </label>
      <button id="start-btn" disabled style="margin-left: 16px">
        å¼€å§‹æµ‹è¯•
      </button>
    </div>

    <div id="status">æ­£åœ¨åˆå§‹åŒ–...</div>

    <div id="progress-container" style="display: none">
      <h2>æµ‹è¯•è¿›åº¦</h2>
      <div class="progress-bar">
        <div id="progress-bar-inner" class="progress-bar-inner">0%</div>
      </div>
    </div>

    <div id="results">
      <h2>æµ‹è¯•ç»“æœ</h2>
      <p>
        <strong>æœ€ç»ˆ mIoU: <span id="miou-value"></span></strong>
      </p>
      <p>å¹³å‡ IoU (Class 0 - èƒŒæ™¯): <span id="iou-class-0"></span></p>
      <p>å¹³å‡ IoU (Class 1 - å‰æ™¯): <span id="iou-class-1"></span></p>
      <p>æ€»è®¡å¤„ç†å›¾ç‰‡æ•°é‡: <span id="total-images"></span></p>
      <p>å¹³å‡æ¨ç†æ—¶é—´/å¼ : <span id="avg-infer-time"></span> ms</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

    <script>
      // --- ç”¨æˆ·é…ç½®åŒº ---
      // æ¨¡å‹è·¯å¾„ä¸è¾“å…¥å°ºå¯¸
      const MODEL_PATH = "./models/tfjs_model/model.json";
      const INPUT_WIDTH = 144;
      const INPUT_HEIGHT = 256;
      // æ•°æ®é›†æ–‡ä»¶åˆ—è¡¨å°†åœ¨ç”¨æˆ·é€‰æ‹©ç›®å½•ååŠ¨æ€ç”Ÿæˆ
      let DATASET_FILES = []; // ä¿å­˜ basename åˆ—è¡¨
      const FRAME_MAP = new Map(); // basename -> File
      const MASK_MAP = new Map(); // basename -> File
      // -----------------
      // æ˜¾ç¤ºå½“å‰åç«¯ä¿¡æ¯
      tf.ready().then(() => {
        const backend = tf.getBackend(); // 'webgl', 'cpu', 'wasm', 'webgpu'...
        document.getElementById("backend-name").innerText = backend;

        // é¢å¤–åœ¨æ§åˆ¶å°è¾“å‡ºç¡¬ä»¶æç¤º
        console.log(`ğŸš€ Using TensorFlow.js backend: ${backend}`);
        if (backend === "webgl" || backend === "webgpu") {
          console.log("âœ… æ¨ç†ä¸»è¦åœ¨ GPU ä¸Šæ‰§è¡Œ");
        } else {
          console.log("â„¹ï¸ æ¨ç†åœ¨ CPU / WebAssembly ä¸Šæ‰§è¡Œ");
        }
      });

      const statusDiv = document.getElementById("status");
      const resultsDiv = document.getElementById("results");
      const progressContainer = document.getElementById("progress-container");
      const progressBarInner = document.getElementById("progress-bar-inner");

      const datasetInput = document.getElementById("dataset-input");
      const startBtn = document.getElementById("start-btn");
      const thresholdInput = document.getElementById("threshold-input");

      // ç›®å½•é€‰æ‹©åï¼Œæ‰«æ frames/ ä¸ masks_binary/ å­ç›®å½•ï¼Œæ„å»ºæ–‡ä»¶æ˜ å°„
      datasetInput.addEventListener("change", () => {
        DATASET_FILES.length = 0;
        FRAME_MAP.clear();
        MASK_MAP.clear();

        for (const file of datasetInput.files) {
          const rel = file.webkitRelativePath || file.name;

          if (rel.includes("frames/") && rel.endsWith(".jpg")) {
            const base = file.name.replace(/\.jpg$/i, "");
            FRAME_MAP.set(base, file);
          } else if (rel.includes("masks_binary/") && rel.endsWith(".png")) {
            const base = file.name.replace(/\.png$/i, "");
            MASK_MAP.set(base, file);
          }
        }

        // ä»…ä¿ç•™åŒæ—¶æ‹¥æœ‰ frame & mask çš„æ ·æœ¬
        for (const [base, frame] of FRAME_MAP) {
          if (MASK_MAP.has(base)) DATASET_FILES.push(base);
        }

        if (DATASET_FILES.length === 0) {
          statusDiv.innerText =
            "âš ï¸ æ‰€é€‰ç›®å½•ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®é›†ï¼ˆéœ€åŒ…å« frames/ ä¸ masks_binary/ï¼‰ã€‚";
          startBtn.disabled = true;
        } else {
          statusDiv.innerText = `âœ… å·²è¯†åˆ«åˆ° ${DATASET_FILES.length} å¼ æœ‰æ•ˆå›¾ç‰‡ï¼Œç‚¹å‡»ã€Œå¼€å§‹æµ‹è¯•ã€ä»¥è¿è¡Œã€‚`;
          startBtn.disabled = false;
        }
      });

      // ç‚¹å‡»æŒ‰é’®åå¯åŠ¨ä¸»æµç¨‹
      startBtn.addEventListener("click", () => {
        startBtn.disabled = true; // é˜²æ­¢é‡å¤ç‚¹å‡»
        main().finally(() => {
          startBtn.disabled = false;
        });
      });

      // ä¸»å‡½æ•°
      async function main() {
        if (DATASET_FILES.length === 0) {
          statusDiv.innerText = "é”™è¯¯ï¼šDATASET_FILES åˆ—è¡¨ä¸ºç©ºã€‚è¯·æ£€æŸ¥ä»£ç ã€‚";
          statusDiv.style.backgroundColor = "#ffcdd2";
          statusDiv.style.borderColor = "#f44336";
          return;
        }

        statusDiv.innerText = "æ­£åœ¨åŠ è½½ TFJS æ¨¡å‹...";
        const model = await tf.loadGraphModel(MODEL_PATH);
        statusDiv.innerText = "æ¨¡å‹åŠ è½½æˆåŠŸ!";
        // é¢„çƒ­æ¨¡å‹
        const warmupTensor = tf.zeros([1, 3, INPUT_HEIGHT, INPUT_WIDTH]);
        model.predict(warmupTensor).dispose();
        warmupTensor.dispose();
        console.log("æ¨¡å‹å·²åŠ è½½å¹¶é¢„çƒ­ã€‚");

        progressContainer.style.display = "block";

        const iouScoresClass0 = [];
        const iouScoresClass1 = [];
        const inferenceTimes = [];

        for (let i = 0; i < DATASET_FILES.length; i++) {
          const baseName = DATASET_FILES[i];
          const frameFile = FRAME_MAP.get(baseName);
          const maskFile = MASK_MAP.get(baseName);
          const progress = ((i + 1) / DATASET_FILES.length) * 100;

          statusDiv.innerText = `æ­£åœ¨å¤„ç†å›¾ç‰‡ ${i + 1} / ${
            DATASET_FILES.length
          }: ${baseName}.jpg`;
          progressBarInner.style.width = `${progress}%`;
          progressBarInner.innerText = `${Math.round(progress)}%`;

          try {
            const { iou0, iou1, timeMs } = await processSingleImage(
              model,
              frameFile,
              maskFile
            );

            if (!isNaN(iou0)) iouScoresClass0.push(iou0);
            if (!isNaN(iou1)) iouScoresClass1.push(iou1);

            inferenceTimes.push(timeMs);

            console.log(
              `Image ${baseName}: IoU Class 0 = ${iou0}, IoU Class 1 = ${iou1}`
            );
          } catch (error) {
            console.error(`å¤„ç†å›¾ç‰‡ ${baseName} æ—¶å‘ç”Ÿé”™è¯¯: `, error);
            statusDiv.innerText = `å¤„ç†å›¾ç‰‡ ${baseName} æ—¶å‡ºé”™: ${error.message}. è¯·æ£€æŸ¥æ§åˆ¶å°ã€‚`;
          }
        }

        calculateAndDisplayResults(
          iouScoresClass0,
          iouScoresClass1,
          inferenceTimes
        );
        model.dispose();
      }

      // å¤„ç†å•å¼ å›¾ç‰‡ï¼šåŠ è½½ã€é¢„å¤„ç†ã€æ¨ç†ã€è®¡ç®—IoU
      async function processSingleImage(model, frameFile, maskFile) {
        const frameTensorUnprocessed = await loadImageToTensor(frameFile);
        const maskTensorUnprocessed = await loadImageToTensor(maskFile, true);

        let iou0_val_num = NaN;
        let iou1_val_num = NaN;
        let inferenceTime = 0;

        tf.tidy(() => {
          const t0 = performance.now();
          const preprocessedFrame = preprocessInput(frameTensorUnprocessed);
          const prediction = model.predict(preprocessedFrame); // Shape: [1, 2, H, W]

          // --- ä¸»è¦ä¿®æ”¹åŒºåŸŸ ---
          // 1. å°†ç±»åˆ«ç»´åº¦(axis 1)æ¢åˆ°æœ€åä¸€ä¸ªç»´åº¦ï¼Œä»¥é€‚åº”tf.softmaxçš„è¦æ±‚
          //    åŸå§‹å½¢çŠ¶: [Batch, Class, Height, Width] -> [1, 2, 256, 144]
          //    ç›®æ ‡å½¢çŠ¶: [Batch, Height, Width, Class] -> [1, 256, 144, 2]
          const transposedPrediction = prediction.transpose([0, 2, 3, 1]);

          // 2. åº”ç”¨Softmax (é»˜è®¤åœ¨æœ€åä¸€ä¸ªç»´åº¦ä¸Šæ“ä½œ)
          const probabilitiesTransposed = transposedPrediction.softmax(); // Shape: [1, H, W, 2]

          // 3. æå–ç±»åˆ«1ï¼ˆå‰æ™¯ï¼‰çš„æ¦‚ç‡å›¾
          //    åœ¨æœ€åä¸€ä¸ªç»´åº¦(ç±»åˆ«ç»´åº¦)ä¸Šsliceå‡ºç´¢å¼•ä¸º1çš„éƒ¨åˆ†
          //    slice at [batch_start, height_start, width_start, class_index_start]
          //    size     [batch_size,  height_size,  width_size,  num_classes_to_slice]
          const class1Probs = probabilitiesTransposed.slice(
            [0, 0, 0, 1],
            [1, -1, -1, 1]
          ); // Shape: [1, H, W, 1]

          // 4. ä¸ 0.5 é˜ˆå€¼æ¯”è¾ƒï¼Œç”Ÿæˆå¸ƒå°”æ©ç 
          const threshold = tf.scalar(parseFloat(thresholdInput.value) || 0.6);
          // .squeeze() ä¼šç§»é™¤æ‰€æœ‰å¤§å°ä¸º1çš„ç»´åº¦ï¼Œè¿™é‡Œä¼šç§»é™¤batchå’Œæœ€åä¸€ä¸ªchannelç»´åº¦, å˜ä¸º [H, W]
          const predictionMask = class1Probs
            .greater(threshold)
            .squeeze()
            .cast("int32");
          // --- ä¿®æ”¹ç»“æŸ ---

          const groundTruthMask = preprocessMask(maskTensorUnprocessed);
          const iou0_tensor = calculateIoUForClass(
            predictionMask,
            groundTruthMask,
            0
          );
          const iou1_tensor = calculateIoUForClass(
            predictionMask,
            groundTruthMask,
            1
          );

          iou0_val_num = iou0_tensor.dataSync()[0];
          iou1_val_num = iou1_tensor.dataSync()[0];
          const t1 = performance.now();
          inferenceTime = t1 - t0;
        });

        frameTensorUnprocessed.dispose();
        maskTensorUnprocessed.dispose();

        return {
          iou0: iou0_val_num,
          iou1: iou1_val_num,
          timeMs: inferenceTime,
        };
      }

      function loadImageToTensor(source, isMask = false) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";

          // æ”¯æŒ File / Blob æˆ– URL å­—ç¬¦ä¸²
          if (source instanceof File || source instanceof Blob) {
            const url = URL.createObjectURL(source);
            img.src = url;
            img.onload = () => {
              URL.revokeObjectURL(url);
            };
          } else {
            img.src = source;
          }

          img.onload = () => {
            const channels = isMask ? 1 : 3;
            const tensor = tf.browser.fromPixels(img, channels);
            resolve(tensor);
          };
          img.onerror = (err) => {
            console.error("åŠ è½½å›¾ç‰‡å¤±è´¥:", err);
            reject(new Error("æ— æ³•åŠ è½½å›¾ç‰‡ã€‚"));
          };
        });
      }

      function preprocessInput(tensor) {
        const resized = tf.image.resizeBilinear(tensor, [
          INPUT_HEIGHT,
          INPUT_WIDTH,
        ]);
        const normalized = resized.div(255.0);
        const transposed = normalized.transpose([2, 0, 1]);
        const batched = transposed.expandDims(0);
        return batched;
      }

      function preprocessMask(tensor) {
        const resized = tf.image.resizeBilinear(tensor, [
          INPUT_HEIGHT,
          INPUT_WIDTH,
        ]);
        return resized.round().cast("int32").squeeze();
      }

      function calculateIoUForClass(predMask, gtMask, classId) {
        const epsilon = tf.scalar(1e-7);
        const pred_is_class = predMask.equal(classId);
        const gt_is_class = gtMask.equal(classId);
        const tp = tf.logicalAnd(pred_is_class, gt_is_class).sum();
        const fp = tf.logicalAnd(pred_is_class, gt_is_class.logicalNot()).sum();
        const fn = tf.logicalAnd(pred_is_class.logicalNot(), gt_is_class).sum();
        const union = tp.add(fp).add(fn);
        return tp.div(union.add(epsilon));
      }

      function calculateAndDisplayResults(iouScores0, iouScores1, inferTimes) {
        const sum = (arr) => arr.reduce((acc, val) => acc + val, 0);
        const avgIou0 =
          iouScores0.length > 0 ? sum(iouScores0) / iouScores0.length : 0;
        const avgIou1 =
          iouScores1.length > 0 ? sum(iouScores1) / iouScores1.length : 0;
        const mIoU = (avgIou0 + avgIou1) / 2;
        const avgTime =
          inferTimes.length > 0 ? sum(inferTimes) / inferTimes.length : 0;

        statusDiv.style.display = "none";
        progressContainer.style.display = "none";
        resultsDiv.style.display = "block";

        document.getElementById("miou-value").innerText = mIoU.toFixed(4);
        document.getElementById("iou-class-0").innerText = avgIou0.toFixed(4);
        document.getElementById("iou-class-1").innerText = avgIou1.toFixed(4);
        document.getElementById("total-images").innerText =
          DATASET_FILES.length;
        document.getElementById("avg-infer-time").innerText =
          avgTime.toFixed(2);

        console.log("--- æµ‹è¯•å®Œæˆ ---");
        console.log(
          `å¤„ç†å›¾ç‰‡æ•°é‡ (è®¡å…¥æœ‰æ•ˆ IoU): Class 0=${iouScores0.length}, Class 1=${iouScores1.length}`
        );
        console.log(`å¹³å‡ IoU (Class 0 - èƒŒæ™¯): ${avgIou0.toFixed(4)}`);
        console.log(`å¹³å‡ IoU (Class 1 - å‰æ™¯): ${avgIou1.toFixed(4)}`);
        console.log(`æœ€ç»ˆ mIoU: ${mIoU.toFixed(4)}`);
        console.log(`å¹³å‡æ¨ç†æ—¶é—´: ${avgTime.toFixed(2)} ms/å¼ `);
      }
    </script>
  </body>
</html>
